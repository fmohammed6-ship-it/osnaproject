```{r}
library(tidycensus)
library(dplyr)
library(tidyr)
library(sf)
library(janitor)
library(stringr)

options(tigris_use_cache = TRUE)

# Chicago Community Areas
ca_sf <- st_read("https://data.cityofchicago.org/resource/igwz-8jzy.geojson") %>%
  janitor::clean_names()

forest_glen <- ca_sf %>% filter(area_num_1 == 12)
```
```{r}
# COMMUTING MODE (B08301)
mobility_vars <- c(
  "B08301_001",  # total commuters (workers 16+)
  "B08301_003",  # drove alone
  "B08301_004",  # carpooled
  "B08301_010",  # public transportation
  "B08301_018",  # walked
  "B08301_019",  # other means
  "B08301_021"   # worked at home
)

# TRAVEL TIME (B08303) – we only need long commutes here
travel_vars <- c(
  "B08303_001",  # total workers (not WFH)
  "B08303_011",  # 45–59 min
  "B08303_012",  # 60–89 min
  "B08303_013"   # 90+ min
)

# VEHICLES AVAILABLE (B08201)
vehicles_vars <- c(
  "B08201_001",  # total households
  "B08201_002",  # 0 vehicles
  "B08201_003",  # 1 vehicle
  "B08201_004",  # 2 vehicles
  "B08201_005",  # 3 vehicles
  "B08201_006"   # 4+ vehicles
)

all_mob_vars <- c(mobility_vars, travel_vars, vehicles_vars)

bg_mob_raw <- get_acs(
  geography = "block group",
  state     = "IL",
  county    = "Cook",
  year      = 2022,   # 2018–2022 ACS 5-year
  variables = all_mob_vars,
  geometry  = TRUE
)

bg_mob_raw
```

```{r}
bg_mob_wide <- bg_mob_raw %>%
  select(GEOID, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  janitor::clean_names()   # columns like b08301_001, b08201_002, etc.

names(bg_mob_wide)

# make sure CRS matches
bg_mob_wide <- st_transform(bg_mob_wide, st_crs(forest_glen))

fg_mob <- st_join(
  bg_mob_wide,
  forest_glen %>% select(area_num_1, community),
  join = st_intersects,
  left = FALSE   # only keep BGs that intersect Forest Glen
)

nrow(fg_mob)      # should be > 1
head(fg_mob$geoid)
```
```{r}
# COMMUTING MODE (B08301)
mobility_vars <- c(
  "B08301_001",  # total commuters (workers 16+)
  "B08301_003",  # drove alone
  "B08301_004",  # carpooled
  "B08301_010",  # public transportation
  "B08301_018",  # walked
  "B08301_019",  # other means
  "B08301_021"   # worked at home
)

# TRAVEL TIME (B08303) – including long commutes
travel_vars <- c(
  "B08303_001",  # total workers (not WFH)
  "B08303_011",  # 45–59 min
  "B08303_012",  # 60–89 min
  "B08303_013"   # 90+ min
)

# VEHICLES AVAILABLE (B08201)
vehicles_vars <- c(
  "B08201_001",  # total households
  "B08201_002",  # 0 vehicles
  "B08201_003",  # 1 vehicle
  "B08201_004",  # 2 vehicles
  "B08201_005",  # 3 vehicles
  "B08201_006"   # 4+ vehicles
)

all_mob_vars <- c(mobility_vars, travel_vars, vehicles_vars)
```
```{r}
bg_mob_raw <- get_acs(
  geography = "block group",
  state     = "IL",
  county    = "Cook",
  year      = 2022,   # 2018–2022 ACS 5-year window
  variables = all_mob_vars,
  geometry  = TRUE
)

bg_mob_wide <- bg_mob_raw %>%
  select(GEOID, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate) %>%
  janitor::clean_names()   # gives b08301_001, b08303_011, etc
```

```{r}

bg_mob_wide <- st_transform(bg_mob_wide, st_crs(forest_glen))

fg_mob <- st_join(
  bg_mob_wide,
  forest_glen %>% select(area_num_1, community),
  join = st_intersects,
  left = FALSE    
)

nrow(fg_mob)         
head(fg_mob$geoid)
```

```{r}
fg_mob_clean <- fg_mob %>%
  mutate(
    # --- commute totals and modes (B08301) ---
    commute_total  = b08301_001,
    drive_alone    = b08301_003,
    carpool        = b08301_004,
    public_transit = b08301_010,
    walk           = b08301_018,
    other_commute  = b08301_019,
    work_at_home   = b08301_021,

    # --- travel time (B08303) ---
    tt_total   = b08303_001,
    tt_45_59   = b08303_011,
    tt_60_89   = b08303_012,
    long_commute_cnt = tt_45_59 + tt_60_89,

    # --- vehicles available (B08201) ---
    hh_total  = b08201_001,
    hh_veh_0  = b08201_002,
    hh_veh_1  = b08201_003,
    hh_veh_2  = b08201_004,
    hh_veh_3  = b08201_005,
    hh_veh_4p = b08201_006
  ) %>%
  # --- mode shares (% of workers) ---
  mutate(
    pct_drive      = if_else(commute_total > 0, 100 * drive_alone    / commute_total, NA_real_),
    pct_carpool    = if_else(commute_total > 0, 100 * carpool        / commute_total, NA_real_),
    pct_transit    = if_else(commute_total > 0, 100 * public_transit / commute_total, NA_real_),
    pct_walk       = if_else(commute_total > 0, 100 * walk           / commute_total, NA_real_),
    pct_other      = if_else(commute_total > 0, 100 * other_commute  / commute_total, NA_real_),
    pct_work_home  = if_else(commute_total > 0, 100 * work_at_home   / commute_total, NA_real_),

    # --- long commute share (>=45 minutes) ---
    pct_long_commute = if_else(tt_total > 0, 100 * long_commute_cnt / tt_total, NA_real_),

    # --- household vehicle structure ---
    pct_hh_veh_0  = if_else(hh_total > 0, 100 * hh_veh_0  / hh_total, NA_real_),
    pct_hh_veh_1  = if_else(hh_total > 0, 100 * hh_veh_1  / hh_total, NA_real_),
    pct_hh_veh_2  = if_else(hh_total > 0, 100 * hh_veh_2  / hh_total, NA_real_),
    pct_hh_veh_3p = if_else(hh_total > 0, 100 * (hh_veh_3 + hh_veh_4p) / hh_total, NA_real_)
  )

# check we kept block groups
nrow(fg_mob_clean)

fg_mob_clean %>%
  st_drop_geometry() %>%
  select(geoid, starts_with("pct_")) %>%
  summary()

```
```{r}
mob_features <- fg_mob_clean %>%
  st_drop_geometry() %>%
  select(
    geoid,
    pct_drive,
    pct_transit,
    pct_walk,
    pct_long_commute,
    pct_hh_veh_0,
    pct_hh_veh_3p
  )

nrow(mob_features)
head(mob_features)

mob_mat <- mob_features %>%
  select(-geoid) %>%
  scale(center = TRUE, scale = TRUE) %>%
  as.matrix()

rownames(mob_mat) <- mob_features$geoid

dim(mob_mat)
```

```{r}
library(dplyr)
library(ggplot2)
library(igraph)

mob_features <- fg_mob_clean %>%
  st_drop_geometry() %>%
  select(
    geoid,
    pct_drive,
    pct_transit,
    pct_walk,
    pct_long_commute
  )

# Drop any rows that are completely NA across these 4
mob_features <- mob_features %>%
  filter(if_any(starts_with("pct_"), ~ !is.na(.)))

nrow(mob_features)
head(mob_features)


mob_mat <- mob_features %>%
  select(-geoid) %>%
  mutate(across(everything(), ~ replace(., is.infinite(.) | is.nan(.), NA_real_))) %>%
  scale(center = TRUE, scale = TRUE) %>%
  as.matrix()

rownames(mob_mat) <- mob_features$geoid

# Remove any rows with NA after scaling (just in case)
valid_rows <- apply(mob_mat, 1, function(x) all(is.finite(x)))
mob_mat <- mob_mat[valid_rows, , drop = FALSE]

mob_ids <- rownames(mob_mat)

dim(mob_mat)
```

```{r}
# Euclidean distance between mobility profiles
mob_dist_mat <- as.matrix(dist(mob_mat, method = "euclidean"))

dim(mob_dist_mat)

# Get non-zero distances for sigma
d_vals <- mob_dist_mat[upper.tri(mob_dist_mat)]
d_vals <- d_vals[d_vals > 0]

sigma <- median(d_vals, na.rm = TRUE)
sigma

# Gaussian similarity: higher = more similar mobility patterns
mob_sim_mat <- exp(-(mob_dist_mat^2) / (2 * sigma^2))
```
```{r}
k <- 5  

edges_list <- lapply(seq_along(mob_ids), function(i) {
  sims <- mob_sim_mat[i, ]
  sims[i] <- NA  # ignore self

  nbrs <- order(sims, decreasing = TRUE)[1:k]

  data.frame(
    from   = mob_ids[i],
    to     = mob_ids[nbrs],
    weight = sims[nbrs],
    stringsAsFactors = FALSE
  )
})

edges_df <- bind_rows(edges_list) %>%
  distinct(from, to, .keep_all = TRUE)

head(edges_df)

# Build igraph object
g_mob <- graph_from_data_frame(
  edges_df,
  directed = FALSE,
  vertices = data.frame(geoid = mob_ids, stringsAsFactors = FALSE)
)

V(g_mob)$geoid <- V(g_mob)$name

# Run Louvain clustering on mobility graph
cl_mob <- cluster_louvain(g_mob, weights = E(g_mob)$weight)
V(g_mob)$mob_cluster <- membership(cl_mob)

table(V(g_mob)$mob_cluster)
```

```{r}
fg_mob_clusters <- fg_mob_clean %>%
  left_join(
    data.frame(
      geoid       = V(g_mob)$geoid,
      mob_cluster = as.factor(V(g_mob)$mob_cluster),
      stringsAsFactors = FALSE
    ),
    by = "geoid"
  )

# Quick map of mobility-based clusters within Forest Glen
ggplot(fg_mob_clusters) +
  geom_sf(aes(fill = mob_cluster), color = "grey30", size = 0.15) +
  scale_fill_viridis_d(na.value = "white") +
  labs(
    title = "Forest Glen – Mobility-Based Clusters of Block Groups",
    fill  = "Mobility\nCluster"
  ) +
  theme_minimal()
```
```{r}
library(dplyr)

mob_summary <- fg_mob_clean %>%
  st_drop_geometry() %>%
  summarise(
    mean_drive = mean(pct_drive, na.rm = TRUE),
    mean_transit = mean(pct_transit, na.rm = TRUE),
    mean_walk = mean(pct_walk, na.rm = TRUE),
    mean_long = mean(pct_long_commute, na.rm = TRUE),
    sd_drive = sd(pct_drive, na.rm = TRUE),
    sd_transit = sd(pct_transit, na.rm = TRUE),
    sd_walk = sd(pct_walk, na.rm = TRUE),
    sd_long = sd(pct_long_commute, na.rm = TRUE)
  )

mob_summary
```
```{r}
library(ggplot2)
df <- fg_mob_clean %>% st_drop_geometry()

ggplot(df, aes(x = pct_drive)) +
  geom_histogram(fill = "#4C72B0", color="white", bins=15) +
  labs(title="Distribution of Driving Alone (%)", x="Drive Alone %", y="Count")

ggplot(df, aes(x = pct_transit)) +
  geom_histogram(fill = "#55A868", color="white", bins=15) +
  labs(title="Distribution of Public Transit (%)")

ggplot(df, aes(x = pct_long_commute)) +
  geom_histogram(fill = "#C44E52", color="white", bins=15) +
  labs(title="Distribution of Long Commute (≥45 mins) %")
```
```{r}
library(reshape2)

mob_cor <- fg_mob_clean %>%
  st_drop_geometry() %>%
  select(pct_drive, pct_transit, pct_walk, pct_long_commute) %>%
  cor(use="complete.obs")

ggplot(melt(mob_cor), aes(Var1, Var2, fill=value)) +
  geom_tile() +
  geom_text(aes(label=round(value, 2)), color="white") +
  scale_fill_gradient2(low="red", mid="white", high="blue", midpoint=0) +
  labs(title="Correlation between Mobility Variables")
```

```{r}
ggplot(df, aes(x=pct_drive, y=pct_transit)) +
  geom_point(size=3, color="#4C72B0") +
  geom_smooth(method="lm", color="darkred") +
  labs(
    title="Drive vs Transit — Forest Glen Block Groups",
    x="Drive Alone (%)",
    y="Transit (%)"
  )
```
```{r}
library(dplyr)
library(igraph)

# Socioeconomic variables used in similarity layer
soc_vars <- c(
  "median_age",
  "median_income",
  "hs_or_more_pct",
  "bachelors_plus_pct",
  "owner_occ_pct",
  "renter_occ_pct"
)

# Filter to Forest Glen (CA 12) and keep only BGs with mobility data (mob_ids)
fg_soc <- study_sf %>%
  filter(ca == 12) %>%
  filter(geoid %in% mob_ids) %>%   # intersect with mobility GEOIDs
  select(geoid, all_of(soc_vars))

nrow(fg_soc)
head(fg_soc)

```

```{r}
library(sf)

# Drop geometry first, then work only with numeric socio-economic columns
fg_soc_num <- fg_soc %>%
  sf::st_drop_geometry() %>%       # <── REMOVE the geometry column
  select(
    geoid,
    median_age,
    median_income,
    hs_or_more_pct,
    bachelors_plus_pct,
    owner_occ_pct,
    renter_occ_pct
  )

soc_mat <- fg_soc_num %>%
  select(-geoid) %>%
  mutate(
    across(
      everything(),
      ~ replace(., is.infinite(.) | is.nan(.), NA_real_)
    )
  ) %>%
  scale(center = TRUE, scale = TRUE) %>%
  as.matrix()

rownames(soc_mat) <- fg_soc_num$geoid

# Drop any rows with NA just in case
valid_soc <- apply(soc_mat, 1, function(x) all(is.finite(x)))
soc_mat <- soc_mat[valid_soc, , drop = FALSE]

soc_ids <- rownames(soc_mat)

length(soc_ids)
soc_ids[1:5]

```
```{r}
# mob_ids comes from your mobility code
common_ids <- intersect(soc_ids, mob_ids)
length(common_ids)

soc_mat_aligned <- soc_mat[common_ids, , drop = FALSE]
mob_mat_aligned <- mob_mat[common_ids, , drop = FALSE]

# sanity check – rownames must match exactly
stopifnot(identical(rownames(soc_mat_aligned), rownames(mob_mat_aligned)))
```
```{r}
# Socioeconomic similarity
soc_dist <- as.matrix(dist(soc_mat_aligned))
soc_sim  <- 1 / (1 + soc_dist)
diag(soc_sim) <- 0

# Mobility similarity (from your mobility matrix)
mob_dist <- as.matrix(dist(mob_mat_aligned))
mob_sim  <- 1 / (1 + mob_dist)
diag(mob_sim) <- 0
```
```{r}
alpha <- 0.5  # weight for socio-economic similarity
beta  <- 0.5  # weight for mobility similarity

combined_sim <- alpha * soc_sim + beta * mob_sim

g_multi <- graph_from_adjacency_matrix(
  combined_sim,
  mode    = "undirected",
  weighted = TRUE,
  diag    = FALSE
)

V(g_multi)$geoid <- rownames(combined_sim)
g_multi
```

```{r}
multi_comm <- cluster_louvain(g_multi, weights = E(g_multi)$weight)
V(g_multi)$multi_cluster <- membership(multi_comm)

mod_multi <- modularity(multi_comm)
mod_multi

table(V(g_multi)$multi_cluster)
```
```{r}
set.seed(123)

plot(
  multi_comm,
  g_multi,
  vertex.size  = 8,
  vertex.label = NA,
  main = "Multilayer Socioeconomic + Mobility Network\nForest Glen Block Groups"
)
```

```{r}
library(dplyr)
library(sf)
library(igraph)

# ---- Already done earlier ----
# - soc_mat (rows = BGs, cols = socioecon vars)
# - mob_mat (rows = BGs, cols = mobility vars)
# - mob_ids <- rownames(mob_mat)
# - study_sf (block-group sf with geoid + ca + socioecon vars)

# Make sure we only keep block groups that have BOTH types of features
soc_ids <- rownames(soc_mat)
common_ids <- intersect(soc_ids, mob_ids)
length(common_ids)

# Align rows in the same order
soc_mat_aligned <- soc_mat[common_ids, , drop = FALSE]
mob_mat_aligned <- mob_mat[common_ids, , drop = FALSE]

# sanity check – rownames must match exactly
stopifnot(identical(rownames(soc_mat_aligned), rownames(mob_mat_aligned)))
```
```{r}
# ---- Socioeconomic similarity layer ----
soc_dist <- as.matrix(dist(soc_mat_aligned))
soc_sim  <- 1 / (1 + soc_dist)
diag(soc_sim) <- 0

g_soc <- graph_from_adjacency_matrix(
  soc_sim,
  mode    = "undirected",
  weighted = TRUE,
  diag    = FALSE
)
V(g_soc)$geoid <- rownames(soc_sim)

soc_comm <- cluster_louvain(g_soc, weights = E(g_soc)$weight)
V(g_soc)$soc_cluster <- membership(soc_comm)
soc_modularity <- modularity(soc_comm)

# ---- Mobility similarity layer ----
mob_dist <- as.matrix(dist(mob_mat_aligned))
mob_sim  <- 1 / (1 + mob_dist)
diag(mob_sim) <- 0

g_mob <- graph_from_adjacency_matrix(
  mob_sim,
  mode    = "undirected",
  weighted = TRUE,
  diag    = FALSE
)
V(g_mob)$geoid <- rownames(mob_sim)

mob_comm <- cluster_louvain(g_mob, weights = E(g_mob)$weight)
V(g_mob)$mob_cluster <- membership(mob_comm)
mob_modularity <- modularity(mob_comm)

# ---- Combined multilayer similarity (your code, cleaned) ----
alpha <- 0.5  # weight for socio-economic similarity
beta  <- 0.5  # weight for mobility similarity

combined_sim <- alpha * soc_sim + beta * mob_sim

g_multi <- graph_from_adjacency_matrix(
  combined_sim,
  mode     = "undirected",
  weighted = TRUE,
  diag     = FALSE
)

V(g_multi)$geoid <- rownames(combined_sim)

multi_comm <- cluster_louvain(g_multi, weights = E(g_multi)$weight)
V(g_multi)$multi_cluster <- membership(multi_comm)

multi_modularity <- modularity(multi_comm)
multi_modularity
table(V(g_multi)$multi_cluster)
```
```{r}
# Extract node-level metrics from each layer
soc_df <- data.frame(
  geoid       = V(g_soc)$geoid,
  soc_cluster = V(g_soc)$soc_cluster,
  soc_deg     = degree(g_soc),
  soc_strength = strength(g_soc, mode = "all")
)

mob_df <- data.frame(
  geoid       = V(g_mob)$geoid,
  mob_cluster = V(g_mob)$mob_cluster,
  mob_deg     = degree(g_mob),
  mob_strength = strength(g_mob, mode = "all")
)

multi_df <- data.frame(
  geoid          = V(g_multi)$geoid,
  multi_cluster  = V(g_multi)$multi_cluster,
  multi_deg      = degree(g_multi),
  multi_strength = strength(g_multi, mode = "all")
)

# Merge all metrics together
node_summary <- soc_df %>%
  left_join(mob_df,   by = "geoid") %>%
  left_join(multi_df, by = "geoid")

head(node_summary)
```
```{r}
fg_with_clusters <- study_sf %>%
  filter(ca == 12, geoid %in% node_summary$geoid) %>%
  left_join(node_summary, by = "geoid")

nrow(fg_with_clusters)
head(fg_with_clusters)
```
```{r}
library(ggplot2)
library(sf)

# Make sure multi_cluster is a factor for nicer colors
fg_with_clusters$multi_cluster <- as.factor(fg_with_clusters$multi_cluster)

ggplot(fg_with_clusters) +
  geom_sf(aes(fill = multi_cluster), color = "white", size = 0.3) +
  scale_fill_brewer(palette = "Set3", name = "Multilayer\nCluster") +
  labs(
    title = "Forest Glen – Multilayer (Socioeconomic + Mobility) Clusters",
    subtitle = "Combined similarity network based on demographics + travel behavior",
    caption = "Block group boundaries shown in white"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 18),
    legend.position = "right",
    panel.grid.major = element_line(color = "transparent"),
    axis.text = element_text(size = 10)
  )
```