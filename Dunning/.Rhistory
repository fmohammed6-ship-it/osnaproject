d_vals <- d_vals[d_vals > 0]
sigma <- median(d_vals, na.rm = TRUE)
gaussian_sim <- exp(-(distance_matrix^2) / (2 * sigma^2))
# Hisham's inverse distance similarity
inverse_sim <- 1 / (1 + distance_matrix)
return(list(
gaussian = gaussian_sim,
inverse = inverse_sim
))
}
# Test on mobility data
mob_dist_mat <- as.matrix(dist(mob_mat, method = "euclidean"))
mob_sims <- calculate_similarities(mob_dist_mat)
mob_dist_mat <- as.matrix(dist(mob_mat, method = "euclidean"))
mob_sims <- calculate_similarities(mob_dist_mat)
# Compare clustering results - FIXED FUNCTION
compare_clustering <- function(sim_matrix, method_name) {
g <- graph_from_adjacency_matrix(sim_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)
comm <- cluster_louvain(g)
return(data.frame(
method = method_name,
modularity = modularity(comm),
n_clusters = length(unique(membership(comm))),
mean_cluster_size = mean(table(membership(comm))),
sd_cluster_size = sd(table(membership(comm)))
))
}
# Now run the comparison
comparison_results <- bind_rows(
compare_clustering(mob_sims$gaussian, "Gaussian"),
compare_clustering(mob_sims$inverse, "Inverse Distance")
)
print("Similarity Method Comparison:")
print(comparison_results)
# MULTILAYER ANALYSIS: Combine your mobility data with Hisham's socioeconomic approach
# Check if we have overlapping data for multilayer analysis
common_ids <- intersect(soc_ids, mob_ids)
cat("Block groups with both mobility and socioeconomic data:", length(common_ids), "\n")
if(length(common_ids) >= 3) {  # Need at least 3 for meaningful clustering
# Align mobility and socioeconomic data
soc_mat_aligned <- soc_mat[common_ids, , drop = FALSE]
mob_mat_aligned <- mob_mat[common_ids, , drop = FALSE]
# Calculate similarities using Hisham's approach
soc_dist <- as.matrix(dist(soc_mat_aligned))
soc_sim  <- 1 / (1 + soc_dist)
diag(soc_sim) <- 0
mob_dist <- as.matrix(dist(mob_mat_aligned))
mob_sim  <- 1 / (1 + mob_dist)
diag(mob_sim) <- 0
# Combined multilayer similarity
alpha <- 0.5  # weight for socio-economic similarity
beta  <- 0.5  # weight for mobility similarity
combined_sim <- alpha * soc_sim + beta * mob_sim
# Create multilayer network
g_multi <- graph_from_adjacency_matrix(
combined_sim,
mode = "undirected",
weighted = TRUE,
diag = FALSE
)
V(g_multi)$geoid <- rownames(combined_sim)
# Detect communities
multi_comm <- cluster_louvain(g_multi, weights = E(g_multi)$weight)
V(g_multi)$multi_cluster <- membership(multi_comm)
cat("Multilayer Network Results:\n")
cat("Vertices:", vcount(g_multi), "\n")
cat("Edges:", ecount(g_multi), "\n")
cat("Communities:", length(unique(membership(multi_comm))), "\n")
cat("Modularity:", round(modularity(multi_comm), 3), "\n")
multilayer_available <- TRUE
} else {
cat("Insufficient data for multilayer analysis. Need at least 3 block groups with both data types.\n")
multilayer_available <- FALSE
}
# VISUAL COMPARISON OF ALL METHODS
# 1. Your Gaussian similarity method
mob_dist_gaussian <- as.matrix(dist(mob_mat, method = "euclidean"))
d_vals <- mob_dist_gaussian[upper.tri(mob_dist_gaussian)]
d_vals <- d_vals[d_vals > 0]
sigma <- median(d_vals, na.rm = TRUE)
gaussian_sim_mat <- exp(-(mob_dist_gaussian^2) / (2 * sigma^2))
k <- 5
edges_list_gaussian <- lapply(seq_along(mob_ids), function(i) {
sims <- gaussian_sim_mat[i, ]
sims[i] <- NA
nbrs <- order(sims, decreasing = TRUE)[1:k]
data.frame(
from = mob_ids[i],
to = mob_ids[nbrs],
weight = sims[nbrs],
method = "Gaussian",
stringsAsFactors = FALSE
)
})
edges_gaussian <- bind_rows(edges_list_gaussian)
g_gaussian <- graph_from_data_frame(edges_gaussian, directed = FALSE, vertices = data.frame(geoid = mob_ids))
cl_gaussian <- cluster_louvain(g_gaussian, weights = E(g_gaussian)$weight)
# 2. Hisham's inverse distance method
inverse_sim_mat <- 1 / (1 + mob_dist_gaussian)
g_inverse <- graph_from_adjacency_matrix(inverse_sim_mat, mode = "undirected", weighted = TRUE)
cl_inverse <- cluster_louvain(g_inverse, weights = E(g_inverse)$weight)
# Prepare data for comparison plots
comparison_data <- data.frame(
geoid = mob_ids,
gaussian_cluster = membership(cl_gaussian),
inverse_cluster = membership(cl_inverse)[match(mob_ids, names(membership(cl_inverse)))]
)
# Add multilayer if available
if(multilayer_available) {
comparison_data$multilayer_cluster <- V(g_multi)$multi_cluster[match(mob_ids, V(g_multi)$geoid)]
}
# Join with spatial data
spatial_comparison <- dunning_mob_clean %>%
filter(geoid %in% mob_ids) %>%
left_join(comparison_data, by = "geoid")
# Create comparison maps
p1 <- ggplot(spatial_comparison) +
geom_sf(aes(fill = as.factor(gaussian_cluster)), color = "white", size = 0.2) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(title = "Gaussian Similarity Method",
subtitle = paste("Modularity:", round(modularity(cl_gaussian), 3))) +
theme_void() +
theme(plot.title = element_text(hjust = 0.5, size = 10))
p2 <- ggplot(spatial_comparison) +
geom_sf(aes(fill = as.factor(inverse_cluster)), color = "white", size = 0.2) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(title = "Inverse Distance Method",
subtitle = paste("Modularity:", round(modularity(cl_inverse), 3))) +
theme_void() +
theme(plot.title = element_text(hjust = 0.5, size = 10))
# Display comparison based on available methods
if(multilayer_available) {
p3 <- ggplot(spatial_comparison) +
geom_sf(aes(fill = as.factor(multilayer_cluster)), color = "white", size = 0.2) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(title = "Multilayer Method",
subtitle = paste("Modularity:", round(modularity(multi_comm), 3))) +
theme_void() +
theme(plot.title = element_text(hjust = 0.5, size = 10))
method_comparison <- p1 + p2 + p3
} else {
method_comparison <- p1 + p2
}
method_comparison <- method_comparison +
plot_annotation(
title = "Comparison of Community Detection Methods in Dunning",
subtitle = "Block group clustering using different similarity measures",
theme = theme(plot.title = element_text(hjust = 0.5, face = "bold"))
)
print(method_comparison)
# DEEP DIVE INTO SIMILARITY METHOD DIFFERENCES
# Compare edge weight distributions
edge_weights_comparison <- data.frame(
method = c(rep("Gaussian", length(E(g_gaussian)$weight)),
rep("Inverse", length(E(g_inverse)$weight))),
weight = c(E(g_gaussian)$weight, E(g_inverse)$weight)
)
# Add multilayer if available
if(multilayer_available) {
edge_weights_comparison <- bind_rows(
edge_weights_comparison,
data.frame(
method = rep("Multilayer", length(E(g_multi)$weight)),
weight = E(g_multi)$weight
)
)
}
p_weights <- ggplot(edge_weights_comparison, aes(x = weight, fill = method)) +
geom_density(alpha = 0.6) +
facet_wrap(~method, scales = "free_y") +
labs(title = "Edge Weight Distributions by Similarity Method",
x = "Edge Weight", y = "Density") +
theme_minimal() +
theme(legend.position = "none")
# Compare network statistics
network_stats <- data.frame(
method = c("Gaussian", "Inverse"),
vertices = c(vcount(g_gaussian), vcount(g_inverse)),
edges = c(ecount(g_gaussian), ecount(g_inverse)),
density = c(edge_density(g_gaussian), edge_density(g_inverse)),
modularity = c(modularity(cl_gaussian), modularity(cl_inverse)),
clusters = c(length(unique(membership(cl_gaussian))),
length(unique(membership(cl_inverse))))
)
# Add multilayer if available
if(multilayer_available) {
network_stats <- bind_rows(
network_stats,
data.frame(
method = "Multilayer",
vertices = vcount(g_multi),
edges = ecount(g_multi),
density = edge_density(g_multi),
modularity = modularity(multi_comm),
clusters = length(unique(membership(multi_comm)))
)
)
}
print("Network Statistics Comparison:")
print(network_stats)
# Visualize network statistics
p_stats <- network_stats %>%
pivot_longer(cols = c(vertices, edges, density, modularity, clusters),
names_to = "metric", values_to = "value") %>%
ggplot(aes(x = method, y = value, fill = method)) +
geom_col(alpha = 0.8) +
facet_wrap(~metric, scales = "free_y") +
labs(title = "Network Statistics by Method",
x = "Method", y = "Value") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print comparisons
print(p_weights)
print(p_stats)
# Method recommendation based on analysis
cat("\nMETHOD RECOMMENDATION:\n")
best_method <- network_stats %>%
filter(modularity == max(modularity)) %>%
pull(method)
cat("Based on modularity, the", best_method, "method performs best.\n")
cat("Modularity scores:\n")
cat("- Gaussian:", round(modularity(cl_gaussian), 3), "\n")
cat("- Inverse Distance:", round(modularity(cl_inverse), 3), "\n")
if(multilayer_available) {
cat("- Multilayer:", round(modularity(multi_comm), 3), "\n")
}
# INTEGRATED COMMUNITY ANALYSIS USING BEST METHOD
# Use the best method for final analysis
if(best_method == "Gaussian") {
final_clusters <- membership(cl_gaussian)
final_graph <- g_gaussian
} else if(best_method == "Inverse") {
final_clusters <- membership(cl_inverse)
final_graph <- g_inverse
} else if(best_method == "Multilayer" && multilayer_available) {
final_clusters <- membership(multi_comm)
final_graph <- g_multi
} else {
# Default to Gaussian if multilayer not available
final_clusters <- membership(cl_gaussian)
final_graph <- g_gaussian
best_method <- "Gaussian"
}
# Create final community map with mobility insights
final_community_data <- dunning_mob_clean %>%
filter(geoid %in% mob_ids) %>%
mutate(
final_cluster = final_clusters[match(geoid, names(final_clusters))],
cluster_type = case_when(
pct_drive > 70 & pct_long_commute < 10 ~ "Car-Dependent, Short Commute",
pct_transit > 30 ~ "Transit-Oriented",
pct_walk > 15 ~ "Walkable",
pct_long_commute > 20 ~ "Long Commute",
TRUE ~ "Mixed Mobility"
)
)
# Final community map
p_final <- ggplot(final_community_data) +
geom_sf(aes(fill = as.factor(final_cluster)), color = "white", size = 0.3) +
scale_fill_viridis_d(name = "Community\nCluster") +
labs(title = paste("Final Community Detection -", best_method, "Method"),
subtitle = paste("Modularity:", round(modularity(
if(best_method == "Gaussian") cl_gaussian else if(best_method == "Inverse") cl_inverse else multi_comm
), 3)),
caption = "Based on integrated mobility and socioeconomic similarity") +
theme_void()
# Mobility patterns by cluster
cluster_mobility_summary <- final_community_data %>%
st_drop_geometry() %>%
group_by(final_cluster) %>%
summarise(
n_block_groups = n(),
avg_drive_pct = mean(pct_drive, na.rm = TRUE),
avg_transit_pct = mean(pct_transit, na.rm = TRUE),
avg_walk_pct = mean(pct_walk, na.rm = TRUE),
avg_long_commute_pct = mean(pct_long_commute, na.rm = TRUE),
dominant_mobility = names(which.max(table(cluster_type)))
)
print("Mobility Patterns by Detected Community:")
print(cluster_mobility_summary)
# Print final results
cat("\nFINAL COMMUNITY ANALYSIS RESULTS:\n")
cat("Best method:", best_method, "\n")
cat("Number of communities:", length(unique(final_clusters)), "\n")
cat("Average community size:", mean(table(final_clusters)), "block groups\n")
cat("Community size range:", min(table(final_clusters)), "-", max(table(final_clusters)), "block groups\n")
# Display final map
print(p_final)
# Your approach map - CORRECTED
# Your approach: Gaussian similarity + k-NN graph (g_gaussian, cl_gaussian)
p_your <- ggplot(spatial_comparison) +
geom_sf(aes(fill = your_cluster), color = "white", size = 0.3, alpha = 0.9) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(
title = "Your Approach: Gaussian Similarity + k-NN",
subtitle = paste(
length(unique(membership(cl_gaussian))), "communities | Modularity:",
round(modularity(cl_gaussian), 3)
),
caption = "k-NN graph with Gaussian similarity"
) +
theme_void() +
theme(
plot.title    = element_text(hjust = 0.5, face = "bold", size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 10),
legend.position = "right"
)
# Hisham's approach: inverse distance on full similarity matrix (g_inverse, cl_inverse)
p_hisham <- ggplot(spatial_comparison) +
geom_sf(aes(fill = hisham_cluster), color = "white", size = 0.3, alpha = 0.9) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(
title = "Hisham's Approach: Inverse Distance + Full Matrix",
subtitle = paste(
length(unique(membership(cl_inverse))), "communities | Modularity:",
round(modularity(cl_inverse), 3)
),
caption = "Full similarity matrix with inverse distance"
) +
theme_void() +
theme(
plot.title    = element_text(hjust = 0.5, face = "bold", size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 10),
legend.position = "right"
)
side_by_side <- p_your + p_hisham +
plot_annotation(
title = "Dunning Block Group Communities: Your Method vs Hisham's Method",
subtitle = "Left: Gaussian + k-NN  |  Right: Inverse Distance + Full Similarity Matrix",
theme = theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
plot.subtitle = element_text(hjust = 0.5)
)
)
print(side_by_side)
cat("Based on modularity, the", best_method, "method performs best.\n")
cat("Modularity scores:\n")
cat("- Gaussian:", round(modularity(cl_gaussian), 3), "\n")
cat("- Inverse Distance:", round(modularity(cl_inverse), 3), "\n")
if(multilayer_available) {
cat("- Multilayer:", round(modularity(multi_comm), 3), "\n")
}
# INTEGRATED COMMUNITY ANALYSIS USING BEST METHOD
# Use the best method for final analysis
if(best_method == "Gaussian") {
final_clusters <- membership(cl_gaussian)
final_graph <- g_gaussian
} else if(best_method == "Inverse") {
final_clusters <- membership(cl_inverse)
final_graph <- g_inverse
} else if(best_method == "Multilayer" && multilayer_available) {
final_clusters <- membership(multi_comm)
final_graph <- g_multi
} else {
# Default to Gaussian if multilayer not available
final_clusters <- membership(cl_gaussian)
final_graph <- g_gaussian
best_method <- "Gaussian"
}
# ========= MY VS HISHAM: CLUSTER LABELS ON SAME BLOCK GROUPS =========
# Put both clustering results into one data frame
comparison_data <- data.frame(
geoid          = mob_ids,
your_cluster   = membership(cl_gaussian),                                             # your Gaussian + k-NN
hisham_cluster = membership(cl_inverse)[match(mob_ids, names(membership(cl_inverse)))] # Hisham inverse-distance
)
# Join with spatial data for mapping
spatial_comparison <- dunning_mob_clean %>%
filter(geoid %in% mob_ids) %>%
left_join(comparison_data, by = "geoid") %>%
mutate(
your_cluster   = as.factor(your_cluster),
hisham_cluster = as.factor(hisham_cluster)
)
# Create final community map with mobility insights
final_community_data <- dunning_mob_clean %>%
filter(geoid %in% mob_ids) %>%
mutate(
final_cluster = final_clusters[match(geoid, names(final_clusters))],
cluster_type = case_when(
pct_drive > 70 & pct_long_commute < 10 ~ "Car-Dependent, Short Commute",
pct_transit > 30 ~ "Transit-Oriented",
pct_walk > 15 ~ "Walkable",
pct_long_commute > 20 ~ "Long Commute",
TRUE ~ "Mixed Mobility"
)
)
# Final community map
p_final <- ggplot(final_community_data) +
geom_sf(aes(fill = as.factor(final_cluster)), color = "white", size = 0.3) +
scale_fill_viridis_d(name = "Community\nCluster") +
labs(title = paste("Final Community Detection -", best_method, "Method"),
subtitle = paste("Modularity:", round(modularity(
if(best_method == "Gaussian") cl_gaussian else if(best_method == "Inverse") cl_inverse else multi_comm
), 3)),
caption = "Based on integrated mobility and socioeconomic similarity") +
theme_void()
# Mobility patterns by cluster
cluster_mobility_summary <- final_community_data %>%
st_drop_geometry() %>%
group_by(final_cluster) %>%
summarise(
n_block_groups = n(),
avg_drive_pct = mean(pct_drive, na.rm = TRUE),
avg_transit_pct = mean(pct_transit, na.rm = TRUE),
avg_walk_pct = mean(pct_walk, na.rm = TRUE),
avg_long_commute_pct = mean(pct_long_commute, na.rm = TRUE),
dominant_mobility = names(which.max(table(cluster_type)))
)
print("Mobility Patterns by Detected Community:")
print(cluster_mobility_summary)
# Print final results
cat("\nFINAL COMMUNITY ANALYSIS RESULTS:\n")
cat("Best method:", best_method, "\n")
cat("Number of communities:", length(unique(final_clusters)), "\n")
cat("Average community size:", mean(table(final_clusters)), "block groups\n")
cat("Community size range:", min(table(final_clusters)), "-", max(table(final_clusters)), "block groups\n")
# Display final map
print(p_final)
# Your approach map - CORRECTED
# Your approach: Gaussian similarity + k-NN graph (g_gaussian, cl_gaussian)
p_your <- ggplot(spatial_comparison) +
geom_sf(aes(fill = your_cluster), color = "white", size = 0.3, alpha = 0.9) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(
title = "Your Approach: Gaussian Similarity + k-NN",
subtitle = paste(
length(unique(membership(cl_gaussian))), "communities | Modularity:",
round(modularity(cl_gaussian), 3)
),
caption = "k-NN graph with Gaussian similarity"
) +
theme_void() +
theme(
plot.title    = element_text(hjust = 0.5, face = "bold", size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 10),
legend.position = "right"
)
# Hisham's approach: inverse distance on full similarity matrix (g_inverse, cl_inverse)
p_hisham <- ggplot(spatial_comparison) +
geom_sf(aes(fill = hisham_cluster), color = "white", size = 0.3, alpha = 0.9) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(
title = "Hisham's Approach: Inverse Distance + Full Matrix",
subtitle = paste(
length(unique(membership(cl_inverse))), "communities | Modularity:",
round(modularity(cl_inverse), 3)
),
caption = "Full similarity matrix with inverse distance"
) +
theme_void() +
theme(
plot.title    = element_text(hjust = 0.5, face = "bold", size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 10),
legend.position = "right"
)
side_by_side <- p_your + p_hisham +
plot_annotation(
title = "Dunning Block Group Communities: Your Method vs Hisham's Method",
subtitle = "Left: Gaussian + k-NN  |  Right: Inverse Distance + Full Similarity Matrix",
theme = theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
plot.subtitle = element_text(hjust = 0.5)
)
)
print(side_by_side)
# ========= MAP 1: YOUR METHOD (GAUSSIAN + k-NN) =========
p_your <- ggplot(spatial_comparison) +
geom_sf(aes(fill = your_cluster), color = "white", size = 0.3, alpha = 0.9) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(
title    = "Your Approach: Gaussian Similarity + k-NN",
subtitle = paste(
length(unique(membership(cl_gaussian))), "communities | Modularity:",
round(modularity(cl_gaussian), 3)
),
caption  = "k-NN graph with Gaussian similarity"
) +
theme_void() +
theme(
plot.title    = element_text(hjust = 0.5, face = "bold", size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 10),
legend.position = "right"
)
# ========= MAP 2: HISHAM'S METHOD (INVERSE DISTANCE, FULL MATRIX) =========
p_hisham <- ggplot(spatial_comparison) +
geom_sf(aes(fill = hisham_cluster), color = "white", size = 0.3, alpha = 0.9) +
scale_fill_viridis_d(name = "Cluster", option = "plasma") +
labs(
title    = "Hisham's Approach: Inverse Distance + Full Matrix",
subtitle = paste(
length(unique(membership(cl_inverse))), "communities | Modularity:",
round(modularity(cl_inverse), 3)
),
caption  = "Full similarity matrix with inverse distance"
) +
theme_void() +
theme(
plot.title    = element_text(hjust = 0.5, face = "bold", size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 10),
legend.position = "right"
)
side_by_side <- p_your + p_hisham +
plot_annotation(
title = "Dunning Block Group Communities: Your Method vs Hisham's Method",
subtitle = "Left: Gaussian + k-NN  |  Right: Inverse Distance + Full Similarity Matrix",
theme = theme(
plot.title    = element_text(hjust = 0.5, face = "bold"),
plot.subtitle = element_text(hjust = 0.5)
)
)
print(side_by_side)
